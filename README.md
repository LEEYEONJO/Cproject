# Cproject
 2025-2-8 - 2025-3-15
# 목차
깃허브 데스크톱
# 깃허브 데스크톱
+ 설치방법
+ https://desktop.github.com/downldad/
# 코드 기본 구성
+ 전처리기
+ main
```C
#include <stdio.h>

int main()
{
    printf("C programming");
    return 0;

}
```

#printf
+ stdio.h에서 제공해주는 C언어의 대표적인 문장 출력용 기능(함수)입니다. 일반적으로는 print("작성하고 싶은 문장")을 작성해 사용합니다.
예시)
```C
int main()
{
    printf("C programming");
    return 0;

}
```
# 서식지정자 
|지정자 명칭|설명|
|-----|-----|
|%d|정수에 대한 지정자|
|%f|실수에 대한 지정자|
|%c|문자에 대한 지정자|

[목차로]

# 변수
+ C언어에서 특정 하나의 데이터를 사용자가 이름지어서 저장하는 방법
+ 변수에 저장된 값은 일반적으로 변형 가능
+ C언어에서 변수는 정해징 데이터의 형태가 존재하고 각 변수는 할당된 값을 가지고 있음.

# 자료형
+ 프로그램어 데이터를 판단하는 기준,데이터의 형태
+ int
+ float
+ char

# 변수를 만들 때 지켜줄 이름 규칙
+ 대소문자를 구분합니다.
+ 변수의 이름은 숫자가 맨 앞에 나올 수 없습니다.
+ 변수의 이름에 특수문자 사용이 불가능합니다.
+ 변수의 이름으로 키워드를 사용할 수 없습니다.

# C언어에서 10진수 이외의 8진수나 16진수를 지정할 수 있습니다.
+ int ocot = 015; (숫자 앞에 0이 붙으면 8진수)
+ int hexa = ox6; (숫자 앞에 0x가 붙으면 16진수)

# #define CRT_SECURE_NO_WARNIGS
+프로그램에서 안전 검사를 하지 않도록 설정하는 코드
+이 코드를 추가할 경우 visual studio 내에서 scanf를 사용할 수 있습니다.

# 입력(input)
+ 사용자가 직접 값을 입력하고 그 값을, 특정 위치에 전달합니다.
+ 일반적으로는 변수를 만들고, 그 변수에 입력한 값을 적용한 방식으로 사용합니다.

# getchar
+ 키보드로부터 하나의 문자를 읽어내는 함수

# purchar(문자)
+ 전달받은 문자 하나를 화면에 출력하는 기능

# gets() , puts()
+ 문자열에 대한 입력과 출력을 진행랄 떄 편하게 사용할 수 있습니다.
+ 문자열이랑 char 형태의 데이터를 묶음으로 표현한 것을 의미합니다.

# 주의사항
+ C언어에서 한글을 입력하는 경우 한글 한 단어에 2칸을 소모합니다.
+ 현재 word는 10개의 단어를 사용할 수 있습니다.
+ 단 입력을 진행할 경우 문자의 개수보다 1개정도 적게 작성합니다.
+ 따라서 영단어는 9글자까지, 한글은 4글자까지 가능.

# 연산자(operator)
+ 프로그램에서 연산을 진행할 때 사용하는 기호
+ ex) 10 + 5 라고 할 때 연산자는 +
+ 연산을 진행할 때 필요한 식이나 값을 항이라고 부르겠습니다.
+ 위의 식에서 +는 10,5 2개의 값이 필요하니 항이 2개라고 표현합니다.(이항)
+ 항이 1개 -> 단항 , 항이 2개 -> 이항 항이 3개 -> 삼항


# 산술 연산자
+    +,   -,    * ,  /  , %
+  더하기,빼기,곱하기,나누기,나머지


  # 대입 연산자
+ = 을 이용해 값을 대입할 수 있습니다.
+ ex) a = 5라고 하면 a에 5의 값을 대입합니다.

# 혼합 대입 연산자
+ = 전에 +,-,*,%를 작성하는 경우 대입하려는 값에 연산을 진행한 결과를 대입합니다.
+ ex) 위의 코드에서 추가적으로 다음과 같이 명령을 작성합니다.
+ a += 5;라고 적으면 a에 5를 더한 결과를 a에 대입합니다. 따라서 10이 됩니다.
+ 즉 a += 5는 a = a + 5와 같은 말입니다.


# 증감 연산자
+ 변수의 값을 1 증가 / 감소 시킬 때 사용하는 연산자(단항)
+ ++, --
+ 작성 위치에 따라 판정이 다르게 처리됩니다.
+ b = a++일 경우를 후위형 증감 연산이라고 부르며, 이 경우에는 연산을 먼저 진행한 뒤, a의 값을 1 증가시킵니다.
+ 따라서 대입 연산에 의해 b는 a(10)의 값을 대입하게 되고, 그 후에 a가 1 증가합니다.
+ b = ++a일 경우를 전위형 증감 연산이라고 부르며, 이 경우에는 a에 대한 1 증가를 먼저 진행하고, 연산을 처리합니다.
+ a가 1 증가해서 12가 되고, 그 후 b에 대입하게 됩니다. b = 12

# 관계연산자
+ 연산자를 기준으로 왼쪽과 오른쪽 값의 크기를 비교해서 참 또는 거짓을 확인합니다.
+ 참일 경우 1을 거짓일 경우 0으로 처리됩니다.
+ 관계 연산자는 아래의 if문 같이 조건에 따라 코드를 작성하는 상황에 사용됩니다.

  # //if(조건식)
```
 {
   조건식이 만족할 때, 실행할 명령문;
  }
	if (a > b)
	{
		printf("a는 b보다 큰 값입니다.\n");
	}
	if (a >= b)
	{
		printf("a는 b보다 크거나 같습니다.\n");
	}

	if (a == b) //a와 b의 크기가 동일한지를 확인합니다.
	{
		printf("a는 b와 같습니다.\n");
	}

	if (a != b)//a와 b가 서로 다른 경우를 확인합니다.
	{
		printf("a는 b와 다릅니다.\n");
	}
	return 0;
}
```
# 연산자 2
+ printf("a = %d b = %d\n0", a, b); // 11 14
+ c = a & b;  // a AND b --> 교집합
+ printf("a & b = %d\n", c); //10

+ c = a | b; //a OR b  --> 합집합
+ a와 b의 값을 전부 1로 처리합니다. 이때 겹치는 값은 겹쳐집니다.
+ printf("a | b = %d\n", c); //15
+ 11 = 1011
+ 14 = 1110
+ c  = 1111


# XOR(Exclusive OR) : 베타적 논리합, 대칭 차집합
+	c = a ^ b; //a XOR b
+ a와 b를 비교하	c = a ^ b; //a XOR b였을 때 비트가 다른 지점을 1, 같으면 0으로 처리합니다,
+ 이 연산 방식은 암호학의 기초로 많이 활용됩니다.
+ 1011
+ 1110
+ 0101  ->  4 + 1 -> 5
+ printf("a ^ b = %d\n",c);

# NOT 연산
+ c = 6;
+	printf("c = %d\n", ~c);
+비트를 반대로 처리하는 연산

# shift 연산
```
a = 1;
c = a << 2;
printf("c = %d\n", c);
	a = 3;
	c = a << 2;
	printf("c = %d\n", c);
	```
+ a << 2일 경우 a를 비트 2칸 이동합니다. 비트 2칸은 2의 2제곱(4)를 의미하니
+ a * 4 로 해석 가능합니다.
```
	a = 16;
	c = a >> 4;
	printf("c = %d\n", c);
```
+ a >> 4일 경우 a를 비트 4칸 이동합니다. 비트 4칸은 2의 4제곱(16)을 의미합니다.
+ a / 16과 동일한 결과

# 2진수 계산법
+ 1. 계산할 값을 2의 제곱수로 분배합니다.
+ 2. 이때 2의 0제곱(1)도 범위에 포함합니다.
+ 3. 가장 큰 값부터 잘라냅니다.
+ 제곱 수
+ 1 2 4 8 16 32 64 128
+ 11 = 8 + 2 + 1 --> 1011
+ 14 = 8 + 4 + 2 --> 1110
+ 11 & 14는 11과 14가 가지고 있는 비트 중에서 겹치는 부분만 1로 처리, 나머지는 다 0으로
+ 1011
+ 1110
+ 1010 => 8 + 2 => 10

# 비트 연산(bitwise)
+ 데이터를 비트 단위로 처리하는 연산자입니다.
+ 컴퓨터는 데이터를 2진 코드로 관리합니다.(이진수)
+ 비트 연산 사용 목적
+ 1. 곱하기와 나누기 연산을 더 빠르게 진행할 수 있습니다.
+ 2. 프로그램에서 이미지 처리하는 직업(ex. RGB 값 분리, 결합, 픽셀 값 조작)
+ 3. 데이터를 압축하는 작업
+ 4. 네트워크 관련 기술(프로토콜 단위에서 IP주소, 포트 번호 같은 데이터를 비트로 분리해
+   네트워크와 호스트 부분에 대한 식별)
+ 5. 임베디드 시스템(하드웨어 레지스터에 대한 조작)
+ 등등 다양한 C언에 관련 기술에서 사용되는 핵심 기술 중 하나입니다.





# Pointer(포인터) : 메모리의 주소 값을 저장하는 변수
+ 어떤 변수의 주소를 가리키는 역할
+ 새로 만드는 게 아닌. 기존의 값을 활용해 가리키고 있는 곳의 변수를 수정하는 것이 가능합니다.

+ 해당 개념에 대한 사용 목적
+ >> 임베디드 프로그래밍 관련 작업 시 많이 활용됩니다.
+ 1. 다양한 형태의 변수들의 접근과 조작이 쉬워집니다.
+ 2. 더 효율적으로 프로그램 작성이 가능해집니다.
+ 3. 컴퓨터의 동작 방식에 대한 이해도가 높아집니다.

# 임베디드 프로그래밍(Embedded Proframming)
+ 하드웨어 기반의 특정 기능 제어(임베디드 시스템)를 진행하는 프로그래밍
+ ex) 자동차, 냉장고, 스마트 워치 등의 기능 담당 하드웨어를 제어하는
+ 소프트웨어에 대한 제작

```
int main()
{
	int value = 100;
	int* ptr_value = &value;
	//1. *(asterisk) : 숫자* 숫자로 쓰일 경우에는 곱하기 기호로 사용
	//                 자료형*로 쓰일 경우는 주소를 값으로 바꿔주는 기능(주소 -> 값)
	//                 포인터에 대한 표현으로 사용합니다.

	//2. &(ampersand) : 값 & 값으로 쓰일 경우에는 해당 값에 대한 비트 AND 연산을 진행하는 기호
	//                  조건식 && 조건식으로 쓰일 경우는 조건식 AND 연산을 진행하는 기호
	//                  &변수명으로 쓰일 경우에는 해당 값을 주소로 바꿔주는 기능(변수 -> 주소)

	value = 5;

	pirntf("value 의 값 %d\n", value); //변수의 값은 그대로 표현
	printf("value 의 주소 %p\n", &value); //변수의 주소 표현시 & 사용
	printf("ptr_value 의 값 %d\n", *ptr_value); //포인터의 변수의 값 표현을 위해 * 사용
	printf("ptr_value 의 주소 %p\n", ptr_value); //포인터는 주소이기 때문에 그대로 표현

	*ptr_value = 7;

	pirntf("value 의 값 %d\n", value); //변수의 값은 그대로 표현
	printf("value 의 주소 %p\n", &value); //변수의 주소 표현시 & 사용
	printf("ptr_value 의 값 %d\n", *ptr_value); //포인터의 변수의 값 표현을 위해 * 사용
	printf("ptr_value 의 주소 %p\n", ptr_value); //포인터는 주소이기 때문에 그대로 표현

	int** pptr_value = &ptr_value;
	//pptr_value는 ptr_value 변수의 주소를 가리키고 있습니다.(이중 포인터)

	//2중 포인터를 만드는 방법
	//자료형** 포인터명 = &포인터변수;
	// 
	//*의 개수가 늘어날때마다 3중,4중포인터로..늘어나게 됨(n중 포인터)

	int*** ppptr_value = &pptr_value;
	printf("pptr_value 의 값 %d\n", **pptr_value);
	printf("ppptr_value 의 값 %d\n", ***ppptr_value);

	//현재 데이터의 관계
	//pptr_value ----> ptr_value -----> value ----> 7



	return 0;
}
```

# 배열

+ 배열의 값(요소 : element)을 넣는 방법
+ 배열명[인덱스] = 값;
+ 인덱스 범위 = 0부터 배열의 길이 -1까지의 범위

+ 배열의 길이를 구하는 방법
+ sizeof(배열명) / sizeof(자료형);

+ 배열의 크기를 구하는 방법
+ sizeof(배열명);

```
int main()
{
	int iArray[5]; //0 ~ 4
	iArray[0] = 1; //iArray의 0번째 요소는 1이 됩니다.
	iArray[1] = 2;
	iArray[2] = 3;
	iArray[3] = 4;
	iArray[4] = 5;

	printf("배열 iArray가 가지고 있는 요소 : ");
	for (int i = 0; i < 5; i++)
	{
		printf("%d ", iArray[i]);
	}
	printf("\n");
    int size = sizeof(iArray);

	printf("배열의 크기 : %d byte\n", size);
	int length = sizeof(iArray) / sizeof(int);
	printf("배열의 길이 : %d\n", length);
	printf("배열의 이름 : %p\n", iArray);

 
 	return 0;
}

```

+ 배열은 같은 형태의 데이터를 묶어서 따로 관리하는 데이터입니다.
+ 각 배열의 요소는 일정한 간격으로 주소를 가지게됩니다.
+ 베열의 첫번째 요소의 주소는 배열의 시작주소입니다.
+ 배열은 선언과 동시에 데이터를 저장할 연속적인 메모리 저장공간을 가지게됩니다.
+ 배열은 지정되는 값으로, 주소에 대한 변경을 진행할 수 없습니다.(수정 불가능한 데이터)

+ 1차원 배열 int iArryay[]
+ 2차원 배열 int iArray2[][]
+ 자료형 배열명[세로열][가로열]


int value3[3][3]; ---> 3 X 3 배열
	value = 1; ----> 시작할 값

for (int i = 0; i < 3; i++)                                  -----> i의 순서 0->1->2(위에서 아래)
	{
		//i가 짝수인 경우에는 순서대로 값이 증가
		if (i % 2 == 0)                              -----> i가 0이거나 2일때
		{
			for (int j = 0; j < 3; j++)          -----> j의 순서 0->1->2(왼쪽에서 오른쪽)
			{
				//1.현재 값의 증가가 아래로 진행되고 있음, 따라서 i와 j의 대입 순서를 변경
				value3[j][i] = value++;        -----> 1-2-3
			}
		}
		else// i가 홀수인 경우라면 반대로 값이 증가하도록 설정    -----> i가 1일때
		{
			for (int j = 2; j >= 0; j--)                     -----> j의 순서 2->1->0(오른쪽에서 왼쪽)
			{
				value3[j][i] = value++;                  -----> 6-5-4
			}
		}
	}

for (int i = 0; i < 3; i++)                                        -----> i의 순서 0->1->2(위에서 아래)
	{
		for (int j = 0; j < 3; j++)                        -----> j의 순서 0->1->2(왼쪽에서 오른쪽)
		{
			printf("%d ", value3[i][j]);              -----> 7-8-9
		}
		printf("\n");
	}












